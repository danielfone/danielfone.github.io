<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Daniel Fone</title>
  <subtitle>Ruby/Rails Engineer</subtitle>
  <id>http://daniel.fone.net.nz/blog</id>
  <link href="http://daniel.fone.net.nz/blog"/>
  <link href="http://daniel.fone.net.nz/atom.xml" rel="self"/>
  <updated>2014-12-10T12:28:00+13:00</updated>
  <author>
    <name>Daniel Fone</name>
  </author>
  <entry>
    <title>Handling Token Generation Collisions In ActiveRecord</title>
    <link rel="alternate" href="http://daniel.fone.net.nz/blog/2014/12/10/handling-token-generation-collisions-in-activerecord/"/>
    <id>http://daniel.fone.net.nz/blog/2014/12/10/handling-token-generation-collisions-in-activerecord/</id>
    <published>2014-12-10T12:28:00+13:00</published>
    <updated>2014-12-10T14:32:41+13:00</updated>
    <author>
      <name>Daniel Fone</name>
    </author>
    <content type="html">&lt;p&gt;&lt;code style="float:right; margin: 0.1em; font-size: 20pt; background: #f1f1f1; padding: 0.1em 0.5em"&gt;
  token=DEC0DE
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In my &lt;a href="/blog/2014/12/07/generating-unique-random-tokens/"&gt;previous post&lt;/a&gt; we looked at generating unique, random tokens to securely identify records with. While UUIDs solve this problem well, they are unweidly. In some cases, it’s handy to have an identifier that’s shorter and hence easier to read out. Naturally, the problem with shorter tokens is collisions. As we reduce our available pool of tokens, the chance that a randomly selected one will be unique goes down quickly.&lt;/p&gt;

&lt;p&gt;Whether this trade off makes sense is entirely dependent on the application. Let’s say we’re identifying an order in a particular month. If we need a short, readable token that’s unique &lt;em&gt;only among this month’s orders&lt;/em&gt;, we can probably use a short token. This is because the number of orders in a given month is not going to grow linearly — we can expect it to hover around a certain percentage of the total available tokens.&lt;/p&gt;

&lt;p&gt;So let’s say we need to keep track of a hundred thousand constantly changing items with a six digit, hexadecimal token. The chance of a random token colliding with an existing one is going to be roughly 0.3%.&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; While this isn’t going to happen frequently, we definitely need to handle the case gracefully.&lt;/p&gt;

&lt;h3 id="a-first-attempt"&gt;A First Attempt&lt;/h3&gt;

&lt;p&gt;The trick is to set the token in a separate SQL query. ActiveRecord’s &lt;code&gt;after_create&lt;/code&gt; is a good fit for this kind of task. In the event of a collision, ActiveRecord will handily raise an &lt;code&gt;ActiveRecord::RecordNotUnique&lt;/code&gt; which we can rescue and retry. If we were setting the token in a &lt;code&gt;before_create&lt;/code&gt;, we wouldn’t be able to simply retry the save.&lt;/p&gt;

&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Order&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;

  &lt;span class="n"&gt;after_create&lt;/span&gt; &lt;span class="ss"&gt;:generate_token&lt;/span&gt;

&lt;span class="kp"&gt;private&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generate_token&lt;/span&gt;
    &lt;span class="n"&gt;update_column&lt;/span&gt; &lt;span class="ss"&gt;:token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;rescue&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;RecordNotUnique&lt;/span&gt;
    &lt;span class="k"&gt;retry&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;&amp;gt; Order.create!
D, [2014-12-10T12:27:16.537985 #19797] DEBUG -- :    (0.1ms)  begin transaction
D, [2014-12-10T12:27:16.538701 #19797] DEBUG -- :   SQL (0.1ms)  INSERT INTO "orders" DEFAULT VALUES
D, [2014-12-10T12:27:16.541939 #19797] DEBUG -- :   SQL (2.6ms)  UPDATE "orders" SET "token" = '99a8b4' WHERE "orders"."id" = 9
E, [2014-12-10T12:27:16.542037 #19797] ERROR -- : SQLite3::ConstraintException: UNIQUE constraint failed: orders.token: UPDATE "orders" SET "token" = '99a8b4' WHERE "orders"."id" = 9
D, [2014-12-10T12:27:16.542747 #19797] DEBUG -- :   SQL (0.1ms)  UPDATE "orders" SET "token" = 'd776b10' WHERE "orders"."id" = 9
D, [2014-12-10T12:27:16.542956 #19797] DEBUG -- :    (0.1ms)  commit transaction
=&amp;gt; #&amp;lt;Order id: 9, token: "d776b10"&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not bad for a first try.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;SecureRandom.hex(3)&lt;/code&gt; produces something like &lt;code&gt;"c41a84"&lt;/code&gt; which is what our tokens should look like.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;update_column&lt;/code&gt; is the fastest way to update the attribute because it goes straight to the database. It’s been around since Rails 3.1.&lt;/li&gt;
  &lt;li&gt;We’re only rescuing in the event of a token collision (&lt;code&gt;ActiveRecord::RecordNotUnique&lt;/code&gt;), so it’s pretty much safe to just retry. But…&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="limited-retries"&gt;Limited Retries&lt;/h3&gt;

&lt;p&gt;While this works, it’s a bad idea to blindly retry without some kind of limit on the number of retries. Even if the system is designed so that the chances of multiple consecutive collisions are tiny, you never know when the system will start operating outside of its original design.&lt;/p&gt;

&lt;p&gt;Let’s introduce a variable to monitor how many retries we’ve made.&lt;/p&gt;

&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generate_token&lt;/span&gt;
  &lt;span class="n"&gt;update_column&lt;/span&gt; &lt;span class="ss"&gt;:token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;rescue&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;RecordNotUnique&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
  &lt;span class="vi"&gt;@token_attempts&lt;/span&gt; &lt;span class="o"&gt;||=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
  &lt;span class="vi"&gt;@token_attempts&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="k"&gt;retry&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vi"&gt;@token_attempts&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
  &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Retries exhausted"&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="highlight plaintext"&gt;&lt;code&gt;D, [2014-12-10T12:50:26.996927 #21209] DEBUG -- :    (0.0ms)  begin transaction
D, [2014-12-10T12:50:26.997180 #21209] DEBUG -- :   SQL (0.0ms)  INSERT INTO "orders" DEFAULT VALUES
D, [2014-12-10T12:50:26.997671 #21209] DEBUG -- :   SQL (0.1ms)  UPDATE "orders" SET "token" = 'c3' WHERE "orders"."id" = 32
E, [2014-12-10T12:50:26.997707 #21209] ERROR -- : SQLite3::ConstraintException: UNIQUE constraint failed: orders.token: UPDATE "orders" SET "token" = 'c3' WHERE "orders"."id" = 32
D, [2014-12-10T12:50:26.998170 #21209] DEBUG -- :   SQL (0.1ms)  UPDATE "orders" SET "token" = '50' WHERE "orders"."id" = 32
E, [2014-12-10T12:50:26.998220 #21209] ERROR -- : SQLite3::ConstraintException: UNIQUE constraint failed: orders.token: UPDATE "orders" SET "token" = '50' WHERE "orders"."id" = 32
D, [2014-12-10T12:50:26.998678 #21209] DEBUG -- :   SQL (0.2ms)  UPDATE "orders" SET "token" = 'cb' WHERE "orders"."id" = 32
E, [2014-12-10T12:50:26.998713 #21209] ERROR -- : SQLite3::ConstraintException: UNIQUE constraint failed: orders.token: UPDATE "orders" SET "token" = 'cb' WHERE "orders"."id" = 32
D, [2014-12-10T12:50:26.998856 #21209] DEBUG -- :    (0.1ms)  rollback transaction
ActiveRecord::RecordNotUnique: Retries exhausted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s functional, but it could be improved. Here’s a slightly nicer version.&lt;/p&gt;

&lt;pre class="highlight ruby"&gt;&lt;code&gt;  &lt;span class="no"&gt;MAX_RETRIES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generate_token&lt;/span&gt;
    &lt;span class="n"&gt;update_column&lt;/span&gt; &lt;span class="ss"&gt;:token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;rescue&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;RecordNotUnique&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
    &lt;span class="vi"&gt;@token_attempts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="vi"&gt;@token_attempts&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;to_i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;retry&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vi"&gt;@token_attempts&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;MAX_RETRIES&lt;/span&gt;
    &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Retries exhausted"&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A few notes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;@token_attempts.to_i&lt;/code&gt; will evaluate to 0 if &lt;code&gt;@token_attempts&lt;/code&gt; hasn’t been previously set. This is because unassigned instance variables are &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;nil.to_i =&amp;gt; 0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;It’s also a good habit to name our fixed numbers via constants. In the original version, the number the 3 was a bit of a magic number. &lt;code&gt;MAX_RETRIES&lt;/code&gt; communicates exactly what this number represents and makes it clear where to change it.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Our &lt;code&gt;raise&lt;/code&gt; encapsulates the original exception with a more helpful message. &lt;code&gt;e.cause&lt;/code&gt; is set to the rescued exception:&lt;/p&gt;

&lt;pre class="highlight plaintext"&gt;&lt;code&gt;[1] pry(#&amp;lt;Order&amp;gt;)&amp;gt; e
=&amp;gt; #&amp;lt;ActiveRecord::RecordNotUnique: Retries exhausted&amp;gt;
[2] pry(#&amp;lt;Order&amp;gt;)&amp;gt; e.cause
=&amp;gt; #&amp;lt;ActiveRecord::RecordNotUnique: SQLite3::ConstraintException: UNIQUE constraint failed: orders.token: UPDATE "orders" SET "token" = '58' WHERE "orders"."id" = 68&amp;gt;
[3] pry(#&amp;lt;Order&amp;gt;)&amp;gt; e.cause.cause
=&amp;gt; #&amp;lt;SQLite3::ConstraintException: UNIQUE constraint failed: orders.token&amp;gt;
[4] pry(#&amp;lt;Order&amp;gt;)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There we have it. If the use-case is right, this is a safe and simple pattern for generating tokens on an ActiveRecord object where there is a reasonable possibility of collisions.&lt;/p&gt;

&lt;div class="footnotes"&gt;
  &lt;ol&gt;
    &lt;li id="fn:1"&gt;
      &lt;p&gt;Once again using the square approximation of the &lt;a href="http://en.wikipedia.org/wiki/Birthday_problem"&gt;Birthday Problem&lt;/a&gt;. &lt;a href="http://www.wolframalpha.com/input/?i=100000+%2F+%282+*+%2816%5E6%29%29"&gt;WolframAlpha&lt;/a&gt;. &lt;a href="#fnref:1" class="reversefootnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>Generating Unique, Random Tokens</title>
    <link rel="alternate" href="http://daniel.fone.net.nz/blog/2014/12/07/generating-unique-random-tokens/"/>
    <id>http://daniel.fone.net.nz/blog/2014/12/07/generating-unique-random-tokens/</id>
    <published>2014-12-07T21:10:00+13:00</published>
    <updated>2014-12-10T14:30:25+13:00</updated>
    <author>
      <name>Daniel Fone</name>
    </author>
    <content type="html">&lt;p&gt;Generating some kind of token for records is a common problem in web development. Fortunately, &lt;a href="http://tools.ietf.org/html/rfc4122"&gt;UUIDs&lt;/a&gt; are designed precisely for generating unique, random IDs or tokens. For most applications, you’ll probably want a fully random &lt;a href="http://tools.ietf.org/html/rfc4122#section-4.4"&gt;v4 UUID&lt;/a&gt;, which you can easily generate with &lt;a href="http://www.ruby-doc.org/stdlib-2.1.4/libdoc/securerandom/rdoc/SecureRandom.html#method-c-uuid"&gt;SecureRandom&lt;/a&gt; in Ruby’s standard library.&lt;/p&gt;

&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'securerandom'&lt;/span&gt;
&lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;uuid&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; "16fc1d86-7d6e-4011-9b75-d6cd9501fe1e"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a widely implemented&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; and instantly recognisable format that is vanishingly unlikely to have a collision.&lt;sup id="fnref:2"&gt;&lt;a href="#fn:2" class="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Now, as an engineer, “unlikely” makes me nervous. I confess I don’t have an intuitive grasp of the statistics involved, and to me the two options are “can’t happen” or “will happen”. Although my rational brain knows better, I still instinctively put “vanishingly unlikely” in the “will happen” category. Sure, a collision might be unlikely if we’re only dealing with a small number of records, but what if we’re dealing with BigData™?&lt;/p&gt;

&lt;p&gt;Well let me put it in perspective for you: you’d have to generate 112 terabytes of UUIDs before you’d even have a &lt;em&gt;one in a billion&lt;/em&gt; chance of a collision.&lt;sup id="fnref:3"&gt;&lt;a href="#fn:3" class="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt; So unless you’ve got a 112 terabyte database to fill with UUIDs, you’re going to have a lot of other problems first.&lt;/p&gt;

&lt;p&gt;How would this look in practice then? If I wanted a token for an ActiveRecord object, it’d look something like:&lt;/p&gt;

&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Order&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
  &lt;span class="n"&gt;before_create&lt;/span&gt; &lt;span class="ss"&gt;:generate_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;unless: :token?&lt;/span&gt;
&lt;span class="kp"&gt;private&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generate_token&lt;/span&gt;
    &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;uuid&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you probably want an index on the &lt;code&gt;token&lt;/code&gt; column, so you might as well make it a unique index. However, a collision is so unlikely to occur there’s really no point handling the RecordNotUnique exception that would be raised in that event.&lt;/p&gt;

&lt;h3 id="other-formats"&gt;Other Formats&lt;/h3&gt;

&lt;p&gt;The downside of UUID is that it’s rather unwieldy. It uses 36 characters to render 16 bytes of entroy.&lt;sup id="fnref:4"&gt;&lt;a href="#fn:4" class="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt; Naturally, there are plenty of other ways to render 16 bytes of entropy and still have the same statistical properties outlined above.&lt;/p&gt;

&lt;p&gt;SecureRandom offers a few other helpful methods for generating token-like strings. My two preferred choices are &lt;code&gt;hex&lt;/code&gt; and &lt;code&gt;urlsafe_base64&lt;/code&gt;. Here they all are for comparison.&lt;/p&gt;

&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;uuid&lt;/span&gt;           &lt;span class="c1"&gt;# =&amp;gt; "8efb5d40-32d8-43c8-a92d-d5f048c8729c"&lt;/span&gt;
&lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hex&lt;/span&gt;            &lt;span class="c1"&gt;# =&amp;gt; "bad6650fc0142451e624bd89b6aa3acf"&lt;/span&gt;
&lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;urlsafe_base64&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; "vp6xjBgi48Jgag6dqH8niw"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="short-memorable-readable-tokens"&gt;Short, Memorable, Readable Tokens&lt;/h3&gt;

&lt;p&gt;What about if the token needs to be really short? I once worked on a project where certain customer facing records had an easy to read reference made of 6 hexadecimal digits. In that case, we only want 3 bytes, and the &lt;code&gt;hex&lt;/code&gt; method conveniently allows us to specify how many bytes we’ll need.&lt;/p&gt;

&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; "bff1a1"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, now we’re only dealing with 16,777,216 possible tokens and collisions are inevitable. In my &lt;a href="/blog/2014/12/10/handling-token-generation-collisions-in-activerecord/"&gt;next post&lt;/a&gt;, we’ll take a look at effective ways to deal with token collisions for ActiveRecord objects.&lt;/p&gt;

&lt;div class="footnotes"&gt;
  &lt;ol&gt;
    &lt;li id="fn:1"&gt;
      &lt;p&gt;You can even generate one from the command line of most *nix systems with &lt;code&gt;uuidgen&lt;/code&gt;. &lt;a href="#fnref:1" class="reversefootnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id="fn:2"&gt;
      &lt;p&gt;This — and the discussion after it — is assuming that the PRNG has sufficient entropy. SecureRandom’s entropy source is system-dependent. &lt;a href="#fnref:2" class="reversefootnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id="fn:3"&gt;
      &lt;p&gt;Given that a UUID is 36 bytes, we want to know how many UUIDs (of which there are 2&lt;sup&gt;112&lt;/sup&gt; total) will give us a one in a billion (2&lt;sup&gt;-30&lt;/sup&gt;) chance of collision. We can plug the square approximation for the &lt;a href="http://en.wikipedia.org/wiki/Birthday_problem"&gt;Birthday Problem&lt;/a&gt; into WolframAlpha to get &lt;a href="http://www.wolframalpha.com/input/?i=sqrt%282+*+2%5E112+*+2%5E-30%29+*+36+bytes"&gt;the result&lt;/a&gt;. &lt;a href="#fnref:3" class="reversefootnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id="fn:4"&gt;
      &lt;p&gt;It’s actually 122 bits since 6 of 128 bits are fixed as per the &lt;a href="http://tools.ietf.org/html/rfc4122#section-4.4"&gt;RFC&lt;/a&gt;. &lt;a href="#fnref:4" class="reversefootnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>Efficient Uniqueness Validations</title>
    <link rel="alternate" href="http://daniel.fone.net.nz/blog/2014/12/05/efficient-uniqueness-validations/"/>
    <id>http://daniel.fone.net.nz/blog/2014/12/05/efficient-uniqueness-validations/</id>
    <published>2014-12-05T13:31:00+13:00</published>
    <updated>2014-12-07T21:12:44+13:00</updated>
    <author>
      <name>Daniel Fone</name>
    </author>
    <content type="html">&lt;p&gt;Although ActiveRecord uniqueness validations aren’t bullet-proof,&lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; they’re often helpful. Unfortunately, they can add overhead to save operations, since they require an extra call to the database. Consider the following simple ActiveRecord class:&lt;/p&gt;

&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SubscriptionPlan&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
  &lt;span class="n"&gt;validates&lt;/span&gt; &lt;span class="ss"&gt;:code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;uniqueness: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
  &lt;span class="n"&gt;validates_uniqueness_of&lt;/span&gt; &lt;span class="ss"&gt;:name&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we try to create this we’ll see two SELECT queries as we’d expect.&lt;/p&gt;

&lt;pre class="highlight plaintext"&gt;&lt;code&gt; &amp;gt;&amp;gt; SubscriptionPlan.create! name: 'Starter - 100', code: 'starter-100'
   (0.2ms)  BEGIN
  SubscriptionPlan Exists (2.1ms)  SELECT  1 AS one FROM "subscription_plans"  WHERE "subscription_plans"."code" = 'starter-100' LIMIT 1
  SubscriptionPlan Exists (0.2ms)  SELECT  1 AS one FROM "subscription_plans"  WHERE "subscription_plans"."name" = 'Starter - 100' LIMIT 1
   (0.1ms)  ROLLBACK
ActiveRecord::RecordInvalid: Validation failed: Code has already been taken, Name has already been taken
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But what about when we update an existing record?&lt;/p&gt;

&lt;pre class="highlight plaintext"&gt;&lt;code&gt;&amp;gt;&amp;gt; plan.update_attributes! quota: 99
   (0.2ms)  BEGIN
    SubscriptionPlan Exists (0.4ms)  SELECT  1 AS one FROM "subscription_plans"  WHERE ("subscription_plans"."code" = 'starter-100' AND "subscription_plans"."id" != 1) LIMIT 1
    SubscriptionPlan Exists (0.2ms)  SELECT  1 AS one FROM "subscription_plans"  WHERE ("subscription_plans"."name" = 'Starter - 100' AND "subscription_plans"."id" != 1) LIMIT 1
  SQL (0.7ms)  UPDATE "subscription_plans" SET "quota" = $1, "updated_at" = $2 WHERE "subscription_plans"."id" = 1  [["quota", 99], ["updated_at", "2014-12-05 00:40:59.969458"]]
   (0.3ms)  COMMIT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We still get two queries to check if the code and name are unique. These are almost certainly pointless, since neither the name or the code have changed, but they’re being checked anyway. On massive tables, these can be costly queries, even with well designed indexes.&lt;/p&gt;

&lt;h3 id="activemodeldirty-to-the-rescue"&gt;ActiveModel::Dirty to the Rescue&lt;/h3&gt;

&lt;p&gt;Fortunately, it’s quite simple to keep these queries in check. &lt;a href="http://api.rubyonrails.org/classes/ActiveModel/Dirty.html"&gt;ActiveModel::Dirty&lt;/a&gt; lets us check if any fields were changed since the record was loaded.&lt;/p&gt;

&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SubscriptionPlan&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
  &lt;span class="n"&gt;validates&lt;/span&gt; &lt;span class="ss"&gt;:code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;uniqueness: &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;if: :code_changed?&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;validates_uniqueness_of&lt;/span&gt; &lt;span class="ss"&gt;:name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;if: :name_changed?&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, create operations behave the same as before, validating the uniqueness of the fields. Likewise if we update one of those fields, it will query only the fields it needs to check.&lt;/p&gt;

&lt;p&gt;On the other hand, an update that doesn’t affect those fields won’t incur the cost of those potentially expensive SELECTS.&lt;/p&gt;

&lt;pre class="highlight plaintext"&gt;&lt;code&gt;&amp;gt;&amp;gt; plan.update_attributes! quota: 99
   (0.2ms)  BEGIN
  SQL (0.7ms)  UPDATE "subscription_plans" SET "quota" = $1, "updated_at" = $2 WHERE "subscription_plans"."id" = 1  [["quota", 99], ["updated_at", "2014-12-05 00:40:59.969458"]]
   (0.3ms)  COMMIT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is much better. However, I think we can do better still. In a future post I’ll look at ways we can bypass manual uniqueness validations entirely.&lt;/p&gt;

&lt;div class="footnotes"&gt;
  &lt;ol&gt;
    &lt;li id="fn:1"&gt;
      &lt;p&gt;Application level uniqueness checks are subject to race conditions, since they use separate check and set queries. They should (almost) always be used in conjunction with a unique index at the database level. See the &lt;a href="http://api.rubyonrails.org/classes/ActiveRecord/Validations/ClassMethods.html#method-i-validates_uniqueness_of"&gt;validates_uniqueness_of docs&lt;/a&gt; for more details. &lt;a href="#fnref:1" class="reversefootnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>Unicode and Regex in Ruby 1.8</title>
    <link rel="alternate" href="http://daniel.fone.net.nz/blog/2014/12/03/unicode-and-regex-in-ruby-1-8/"/>
    <id>http://daniel.fone.net.nz/blog/2014/12/03/unicode-and-regex-in-ruby-1-8/</id>
    <published>2014-12-03T23:33:00+13:00</published>
    <updated>2014-12-04T00:29:53+13:00</updated>
    <author>
      <name>Daniel Fone</name>
    </author>
    <content type="html">&lt;p&gt;For the last 6 months, I have been locked in mortal combat with the worst type of bug ever. It is the kind of bug that demonstrably occurs in production, but it is very intermittent, and you cannot ever reproduce it.&lt;/p&gt;

&lt;p&gt;Finally today, that bug is no more.&lt;/p&gt;

&lt;h4 id="the-problem"&gt;The Problem&lt;/h4&gt;

&lt;p&gt;Users of this particular app can submit comments on ‘tasks’. Comments can contain mentions of other users with a &lt;code&gt;@user&lt;/code&gt; syntax, much like Github. This notifies the mentioned user(s) of the comment.&lt;/p&gt;

&lt;p&gt;Although it had been working fine, it started intermittently failing — less than 1% of the time. Although it wasn’t frequent, it was incredibly unhelpful because commenters wouldn’t know that their message hadn’t been sent, and would blindly wait for some response.&lt;/p&gt;

&lt;h4 id="failing-to-diagnose"&gt;Failing to Diagnose&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;The regex that matched metions was &lt;code&gt;/(?:^|\W)@(\w+)/&lt;/code&gt;, which worked fine in every test case we had.&lt;/li&gt;
  &lt;li&gt;Even when I had examples of failing comments, I could copy them out of the database, run them through the parser, and they would correctly send all the notifications.&lt;/li&gt;
  &lt;li&gt;I could &lt;em&gt;not&lt;/em&gt; see why the mentions weren’t getting parsed, and I couldn’t reproduce the errors.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="breakthrough"&gt;Breakthrough&lt;/h4&gt;

&lt;p&gt;The relevant parts of the process for these mentions were as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Take a (potentially HTML) comment&lt;/li&gt;
  &lt;li&gt;Convert it to plain text&lt;/li&gt;
  &lt;li&gt;Parse it for mentions and send notifications&lt;/li&gt;
  &lt;li&gt;Save it to the database&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After countless hours of debugging, I discovered the gotcha was in step 2. The HTML to text conversion would (among other things) take HTML entities and convert them to their unicode equivalents. This wasn’t a problem &lt;em&gt;unless&lt;/em&gt; the entity happened to be an &lt;code&gt;&amp;amp;nbsp;&lt;/code&gt; which would sometimes randomly appear in front of @mentions. This would then be converted to a unicode ‘NO-BREAK SPACE’ (U+00A0) which looks &lt;strong&gt;exactly&lt;/strong&gt; the same as a space.&lt;/p&gt;

&lt;p&gt;When this unicode character occurred before a mention, Ruby 1.8 &lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; would no longer match the &lt;code&gt;\W&lt;/code&gt; portion of the regex and the user would never be notified. By the time the comment was in the database, the unicode was gone and the cause was entirely obscured.&lt;/p&gt;

&lt;h4 id="solution"&gt;Solution&lt;/h4&gt;

&lt;p&gt;As is often the case, having a reproducible fault made the solution easy. Simply normalising unicode before trying to parse the comments for mentions completely eliminated the issue. In this instance, Iconv did the trick, and the whole method ended up something like this:&lt;/p&gt;

&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;parse_mentions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;comment&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;normalized_comment&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Iconv&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;conv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'ASCII//TRANSLIT//IGNORE'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'UTF8'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;comment&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;names&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;normalized_comment&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;scan&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sr"&gt;/(?:^|\W)@(\w+)/&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nf"&gt;flatten&lt;/span&gt;
  &lt;span class="no"&gt;User&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;all&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:conditions&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;names&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="ss"&gt;:select&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="ss"&gt;:email&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nf"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="ss"&gt;:email&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Phew.&lt;/p&gt;

&lt;div class="footnotes"&gt;
  &lt;ol&gt;
    &lt;li id="fn:1"&gt;
      &lt;p&gt;Thankfully, in modern versions of Ruby, this regex matches unicode exactly as you’d expect it to. &lt;a href="#fnref:1" class="reversefootnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>Fixing Connection Errors After Upgrading Postgres</title>
    <link rel="alternate" href="http://daniel.fone.net.nz/blog/2014/12/01/fixing-connection-errors-after-upgrading-postgres/"/>
    <id>http://daniel.fone.net.nz/blog/2014/12/01/fixing-connection-errors-after-upgrading-postgres/</id>
    <published>2014-12-01T12:43:00+13:00</published>
    <updated>2014-12-06T22:43:16+13:00</updated>
    <author>
      <name>Daniel Fone</name>
    </author>
    <content type="html">&lt;p&gt;I recently upgraded Postgres from 9.2 to 9.3 using &lt;code&gt;brew upgrade postgres&lt;/code&gt;. The process was smooth and &lt;code&gt;pg_upgrade&lt;/code&gt; is a very handy tool.&lt;/p&gt;

&lt;p&gt;However, trouble struck once I tried to run any specs that needed to connect to Postgres. Even though Postgres was &lt;em&gt;definitely&lt;/em&gt; running, suddenly I was getting:&lt;/p&gt;

&lt;pre class="highlight plaintext"&gt;&lt;code&gt;could not connect to server: No such file or directory (PG::ConnectionBad)
Is the server running locally and accepting
connections on Unix domain socket "/var/pgsql_socket/.s.PGSQL.5432"?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem was that the new version of Postgres listens on /tmp/.s.PGSQL.5432 instead. I could’ve messed around with the config and made Postgres use the domain socket it was previously, or told Rails explictly how to connect, but both of those approaches seemed like work I shouldn’t have to do. At no point had I told Rails to connect to postgres on that path, Rails had assumed it, and now its assumptions were wrong.&lt;/p&gt;

&lt;p&gt;The fix is simple, if a little suprising. When you install the ‘pg’ gem, it detects which version of Postgres is installed and sets the domain socket path appropriately. The solution is as simple as reinstalling the gem.&lt;/p&gt;

&lt;pre class="highlight plaintext"&gt;&lt;code&gt;$ gem uninstall pg
$ cd my-rails-app/
$ bundle install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hat tip to &lt;a href="http://tammersaleh.com/posts/installing-postgresql-for-rails-3-1-on-lion/"&gt;Tammer Selah&lt;/a&gt; and this &lt;a href="http://stackoverflow.com/questions/6770649/repairing-postgresql-after-upgrading-to-osx-10-7-lion#comment8687127_6772559"&gt;Stack Overflow comment&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Devise causing a CookieOverflow error</title>
    <link rel="alternate" href="http://daniel.fone.net.nz/blog/2014/11/28/actiondispatch-cookies-cookieoverflow-via-devise-s-user_return_to/"/>
    <id>http://daniel.fone.net.nz/blog/2014/11/28/actiondispatch-cookies-cookieoverflow-via-devise-s-user_return_to/</id>
    <published>2014-11-28T10:51:00+13:00</published>
    <updated>2014-11-28T22:03:00+13:00</updated>
    <author>
      <name>Daniel Fone</name>
    </author>
    <content type="html">&lt;p&gt;Today I came across an exception that was caused by a collision of two uncommon circumstances:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A large and complex form, submitted via GET (it was a search form with a &lt;em&gt;lot&lt;/em&gt; of parameters)&lt;/li&gt;
  &lt;li&gt;A Devise session time out&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="how-it-happens"&gt;How It Happens&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;A user who signed in some time ago has the form open. They submit the form which GETs a very long url from the server.&lt;/li&gt;
  &lt;li&gt;Devise attempts to authenticate the user and realises that their session has expired.&lt;/li&gt;
  &lt;li&gt;Devise attempts to redirect the user to the sign in form, but first it stores the url in the session as &lt;code&gt;user_return_to&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The url is too long to fit in the session and a ActionDispatch::Cookies::CookieOverflow exception is raised.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="reproducible-test-case"&gt;Reproducible Test Case&lt;/h3&gt;

&lt;p&gt;Fortunately, it’s very easy to replicate the problem in tests. Anytime an unauthenticated user requests a url approaching ActionDispatch::Cookies::MAX_COOKIE_SIZE, Devise will attempt to store the the url and cause the exception to be raised.&lt;/p&gt;

&lt;pre class="highlight ruby"&gt;&lt;code&gt;  &lt;span class="c1"&gt;# /spec/requests/large_request_spec.rb&lt;/span&gt;
  &lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'spec_helper'&lt;/span&gt;

  &lt;span class="no"&gt;RSpec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;describe&lt;/span&gt; &lt;span class="s1"&gt;'A very large request'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;type: :request&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="s1"&gt;'should not overflow cookies'&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="s1"&gt;'/'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;foo: &lt;/span&gt;&lt;span class="s1"&gt;'x'&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="no"&gt;ActionDispatch&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Cookies&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;MAX_COOKIE_SIZE&lt;/span&gt;
      &lt;span class="n"&gt;expect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nf"&gt;to&lt;/span&gt; &lt;span class="n"&gt;redirect_to&lt;/span&gt; &lt;span class="s1"&gt;'/users/sign_in'&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This reliably produces&lt;/p&gt;

&lt;pre class="highlight plaintext"&gt;&lt;code&gt;1) A very large request should not overflow cookies
   Failure/Error: get '/', foo: 'bar' * 1000
   ActionDispatch::Cookies::CookieOverflow:
     ActionDispatch::Cookies::CookieOverflow
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="solutions"&gt;Solutions&lt;/h3&gt;

&lt;p&gt;There were a couple of approaches that I didn’t want to pursue.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Changing the form method to POST. This substantially alters the behaviour of the form, “breaking” the back and refresh functionality, and preventing users from easily sharing search results.&lt;/li&gt;
  &lt;li&gt;Abbreviating the parameter name. Because the forms are all generated by rails helpers, this would require overriding a lot of simple behaviour. The form is also dynamic and the number of GET parameters is not fixed. This means we can never ensure that the GET url will be small enough.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ultimately, I wanted to solve this at the Devise level. The problematic behaviour is defined in the &lt;a href="https://github.com/plataformatec/devise/blob/v3.4.1/lib/devise/controllers/store_location.rb"&gt;store_location module&lt;/a&gt;, which is included into Devise’s &lt;a href="https://github.com/plataformatec/devise/blob/a93edc72fd9f6cc5839dd74107b215a81c16dc37/lib/devise/failure_app.rb"&gt;failure app&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I wrote a simple initializer to monkey patch the method and prevent it storing excessively long urls in the session.&lt;/p&gt;

&lt;script src="https://gist.github.com/danielfone/c8ab593c326a8052651c.js"&gt;&lt;/script&gt;

&lt;p&gt;The downside to this approach is that the user loses their place in the form, but it is far better than an unhandled exception when submitting. I’ve submitted a &lt;a href="https://github.com/plataformatec/devise/pull/3347"&gt;pull request&lt;/a&gt; to the Devise project, but to be honest this is such an edge case that it may not warrant it. We’ll see what happens.&lt;/p&gt;

</content>
  </entry>
</feed>
