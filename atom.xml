<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Daniel Fone</title>
  <subtitle>Ruby/Rails Engineer</subtitle>
  <id>http://daniel.fone.net.nz/blog</id>
  <link href="http://daniel.fone.net.nz/blog"/>
  <link href="http://daniel.fone.net.nz/atom.xml" rel="self"/>
  <updated>2020-10-21T20:58:00+13:00</updated>
  <author>
    <name>Daniel Fone</name>
  </author>
  <entry>
    <title>Talking, Typing, Thinking: Software Is Not a Desk Job</title>
    <link rel="alternate" href="http://daniel.fone.net.nz/blog/2020/10/21/talking-typing-thinking-software-is-not-a-desk-job/"/>
    <id>http://daniel.fone.net.nz/blog/2020/10/21/talking-typing-thinking-software-is-not-a-desk-job/</id>
    <published>2020-10-21T20:58:00+13:00</published>
    <updated>2020-10-22T09:55:16+13:00</updated>
    <author>
      <name>Daniel Fone</name>
    </author>
    <content type="html">&lt;p&gt;I had a wonderful shower the other day.&lt;/p&gt;

&lt;p&gt;It was late morning (as the best showers often are) and I was reflecting on how I spend my time during the day. As a work-from-home consultant, I constantly need to justify my billing and my time, and in this case I was justifying spending more of it in the shower.&lt;/p&gt;

&lt;p&gt;Like most of us, I started my career with the impression that a productive day was spent ergonomically poised over a keyboard typing hundreds of lines of code into Microsoft Visual Basic 6.0 Professional Edition, and &lt;em&gt;not&lt;/em&gt; standing in a perfectly hot stream of high pressure fresh water. However, the longer I spend as a developer, the less I‚Äôm convinced I need to be at my desk to deliver the truly astounding spreadsheet-to-web-application business value us senior engineering consultants deliver.&lt;/p&gt;

&lt;p&gt;So that you too can justify spending the good part of a morning enveloped in a cocoon of cleansing warmth, let‚Äôs break this down and look at 5 physical activities of effective software development. Like all good listicles, this is ordered roughly in order of increasing time and importance.&lt;/p&gt;

&lt;h2 id="talking"&gt;5. Talking&lt;/h2&gt;

&lt;p&gt;Some software development probably doesn‚Äôt need any talking to be effective. I understand for example that it is universally considered bad manners to talk about linux kernel development out loud. The contents of ~/bin too, we do not speak of.&lt;/p&gt;

&lt;p&gt;But every commercial project I‚Äôve worked on has needed at least some talking. When people are too busy or just too shy to talk, the lack of high-bandwidth communication can make it hard to tease out requirements and unpack poorly explained business problems.&lt;/p&gt;

&lt;p&gt;But more importantly, a lack of talking makes it hard to build trust and rapport ‚Äî critical¬†in early stages of any new relationship. As social animals, we are particularly good at doing this verbally, and not particularly good at doing this with emails and spicy subtweets.&lt;/p&gt;

&lt;p&gt;On the other hand I‚Äôve worked on projects where talking is a prop to disguise that no-one knows what to do. Where a dozen people sit in a room and talk for an hour without saying anything and we all walk out dumber than when we walked in.&lt;/p&gt;

&lt;p&gt;So for most cases: talking is critical, but in the right amount.&lt;/p&gt;

&lt;h2 id="listening"&gt;4. Listening&lt;/h2&gt;

&lt;p&gt;Honestly I just included this for symmetry. The only thing I‚Äôll add is that we have two ears and one mouth so either binaural hearing offers an evolutionary advantage against some selection pressure or we‚Äôre supposed to listen twice as much as we talk.&lt;/p&gt;

&lt;p&gt;Take your pithy wisdom however you like it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(quickly googles why do we have two ears)&lt;/em&gt;&lt;/p&gt;

&lt;h2 id="writing"&gt;3. Writing&lt;/h2&gt;

&lt;p&gt;Writing code of course! But also‚Ä¶ READMEs, comments, inline documentation, PR descriptions, code reviews, git commits; this is all part of the &lt;em&gt;core work&lt;/em&gt;. It‚Äôs tempting to see this meta-writing as overhead on top of the real ‚Äòcode‚Äô writing. But effective writing in these other places is a force multiplier for your code.&lt;/p&gt;

&lt;p&gt;Much more importantly though, in my experience the best communication is written.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It‚Äôs async, meaning it can be consumed whenever convenient for each reader (i.e. after a late morning shower).&lt;/li&gt;
  &lt;li&gt;It can be easily distributed and has no fidelity loss when shared (compared to talking to John about what Sarah told you Steve said in meeting that none of you were at).&lt;/li&gt;
  &lt;li&gt;It creates a record, as opposed to ‚Äúwait, why did we‚Ä¶?‚Äù&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://alistapart.com/article/writing-is-thinking/"&gt;Writing is thinking&lt;/a&gt;! Writing forces you to structure your ideas coherently (at least, it seems to for some people). It reveals shortcomings or gaps in your understanding or plan.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because of this I encourage team comms to be mostly written. Jira, slack, emails, trello, blog posts, whatever. Even a hi-res photo of a wall of post-it notes has been an indispensable architectural road-map at times. However it‚Äôs published, detailed, well-thought out writing is üíØ.&lt;/p&gt;

&lt;p&gt;Perhaps even more important than writing though is‚Ä¶&lt;/p&gt;

&lt;h2 id="reading"&gt;2. Reading&lt;/h2&gt;

&lt;p&gt;Having just extolled the virtues of writing READMEs, commit messages, PR descriptions, etc, I should obviously encourage you to read them. It‚Äôs called README IN CAPITALS for a reason, and it‚Äôs not just because it‚Äôs an acronym. Yet if I had a dollar for every time someone asked me a question that was already answered in the README I would have three dollars. üí∞&lt;/p&gt;

&lt;p&gt;This is because of what I succinctly call the vicious-reading-writing-cycle-feedback-loop. When people don‚Äôt update the commentary, people become trained to ignore it, so people don‚Äôt update it, etc. Truthfully, if you know someone‚Äôs reading your git commits, their quality will rapidly improve. Even if you‚Äôve never read a coherent git commit from your colleagues before, it‚Äôs never too late to ask them to elaborate on what &lt;code&gt;finally fix it&lt;/code&gt; means.&lt;/p&gt;

&lt;p&gt;But like writing, the value of reading extends well beyond the code repository.&lt;/p&gt;

&lt;p&gt;I recently started a project involving a completely unfamiliar field of medical technology (ps you‚Äôre &lt;a href="https://twitter.com/danielfone/status/1318026784454045703"&gt;still my favourite&lt;/a&gt; patient &lt;code&gt;01-004&lt;/code&gt; üìä‚ù§Ô∏è). The most valuable activity I find at this stage of a project is to read.&lt;/p&gt;

&lt;p&gt;We have to parse a &lt;a href="https://en.wikipedia.org/wiki/European_Data_Format"&gt;specialised file format&lt;/a&gt;, for which there is &lt;a href="https://github.com/nsrr/edfize"&gt;a gem&lt;/a&gt;. But why leave all that useful context buried inside the gem? The &lt;a href="https://www.edfplus.info/specs/edf.html"&gt;file specification&lt;/a&gt; is not that long, even if it takes many attempts to understand it. Reading the file format spec makes it much easier to understand why the gem needs to &lt;a href="https://github.com/nsrr/edfize/blob/93566cdc82b160ef319c51908c1c4a19666e2625/lib/edfize/edf.rb#L243"&gt;load_digital_signals_by_epoch&lt;/a&gt;, which in turn suggests alternative solutions to the problem you have in hand.&lt;/p&gt;

&lt;p&gt;None of the &lt;em&gt;adjacent possible&lt;/em&gt;&lt;sup id="fnref:1" role="doc-noteref"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; is discoverable without the insights gained from reading these sources, so whatever you‚Äôre dealing with, go to the source and read read read‚Ä¶&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;documentation (&lt;em&gt;reading the very well-written &lt;a href="https://www.postgresql.org/docs/current/index.html"&gt;postgres manual&lt;/a&gt; or &lt;a href="https://redis.io/documentation"&gt;redis docs&lt;/a&gt; is the closet experience I‚Äôve had to Neo downloading kung-fu into his brain&lt;/em&gt;)&lt;/li&gt;
  &lt;li&gt;code (&lt;em&gt;vastly underrated - there‚Äôs not a gem in my Gemfiles I haven‚Äôt &lt;code&gt;bundle open&lt;/code&gt;d at least once&lt;/em&gt;)&lt;/li&gt;
  &lt;li&gt;log files, error messages, that tutorial on how to read flame graphs&lt;/li&gt;
  &lt;li&gt;the specification, legislation, policy document, NIST guideline, the original paper in the open access journal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;‚Ä¶ you get the idea, just find the authoritative document and slurp it into your brain. Even if it seems like nothing sticks, a brief encounter with the text will leave a long-lasting impression. It‚Äôs like homeopathy but real.&lt;/p&gt;

&lt;p&gt;So talking/listening‚Ä¶ writing/reading‚Ä¶ and finally‚Ä¶ &lt;em&gt;drumroll noises&lt;/em&gt;&lt;/p&gt;

&lt;h2 id="thinking"&gt;1. Thinking&lt;/h2&gt;

&lt;p&gt;When you boil it down, &lt;em&gt;this&lt;/em&gt; is the main effort for me, and yet it‚Äôs kind of the hidden one.&lt;/p&gt;

&lt;p&gt;How much of my programming/coding/dev time is actually just spent &lt;em&gt;thinking&lt;/em&gt; about the problems?
Modelling the domain,
thinking through the edge cases,
mentally playing with abstractions.&lt;/p&gt;

&lt;p&gt;And it‚Äôs obvious when you think about what makes good developers. The people I value working with most aren‚Äôt accurate typists, they‚Äôre &lt;em&gt;clear thinkists&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Yet the image persists that typing is working and working is typing and a productive day is in your chair at your desk.
So we have dual 4k monitors, mechanical keyboards, aeron chairs, touchbar, vim shortcuts, whatever optimises for us tapping away at our computers.&lt;/p&gt;

&lt;p&gt;But how much attention do we pay to the &lt;strong&gt;ergonomics of thinking&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;When we elevate ‚Äòthinking‚Äô to core work, we naturally start to optimise for it specifically. In general, we don‚Äôt need to be in front of anything to think effectively, and often I find it better not to be. My times of greatest clarity are invariably when I‚Äôm moving, often when I‚Äôm exercising. Further, I can read on my phone practically anywhere, and the best conversations are often had while strolling.&lt;/p&gt;

&lt;p&gt;So while I‚Äôm glad for all the ergonomics of my workspace, increasingly I find that writing code is the brief part where I‚Äôm simply harvesting all the mental crop that I‚Äôve sown from the talking and listening and reading and thinking.&lt;/p&gt;

&lt;p&gt;To distill this into something a little more alliterative, I have sometimes described this as the 3 Ts of software development‚Ä¶&lt;/p&gt;

&lt;h2 style="text-align: center"&gt;Talking ¬∑ Typing ¬∑ Thinking&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Talking&lt;/strong&gt; and listening; the verbal discussions. Most of the time we need a small but critical amount of high bandwidth synchronous comms.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Typing&lt;/strong&gt; code commentary: READMEs, code reviews, PR descriptions; and all asynchronous communication: project updates, technical overviews, emails with next steps; These are all an essential part of the job and not just ancillary or busywork. Also typing actual code at some point. But I find the more time you spend typing the other stuff, the less time you need to spend (re)typing code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thinking&lt;/strong&gt;: (including, for the purposes of alliteration, reading)&lt;/p&gt;

&lt;p&gt;Talking, typing, thinking: this is the work we do. And I for one want to give myself the space to do all parts of it really well.&lt;/p&gt;

&lt;p&gt;Anyway, I gotta go take a shower. üöø&lt;/p&gt;

&lt;div class="footnotes" role="doc-endnotes"&gt;
  &lt;ol&gt;
    &lt;li id="fn:1" role="doc-endnote"&gt;
      &lt;p&gt;per &lt;a href="https://www.wsj.com/articles/SB10001424052748703989304575503730101860838"&gt;Steven Johnson in the WSJ&lt;/a&gt;&lt;/p&gt;

      &lt;blockquote&gt;
        &lt;p&gt;The adjacent possible is a kind of shadow future, hovering on the edges of the present state of things, a map of all the ways in which the present can reinvent itself.&lt;/p&gt;
      &lt;/blockquote&gt;
      &lt;p&gt;&lt;a href="#fnref:1" class="reversefootnote" role="doc-backlink"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>Browser Geolocation API Demo</title>
    <link rel="alternate" href="http://daniel.fone.net.nz/blog/2020/09/14/geolocation-api-demo/"/>
    <id>http://daniel.fone.net.nz/blog/2020/09/14/geolocation-api-demo/</id>
    <published>2020-09-14T20:37:00+12:00</published>
    <updated>2020-09-15T10:49:05+12:00</updated>
    <author>
      <name>Daniel Fone</name>
    </author>
    <content type="html">&lt;p&gt;I was recently investigating the feasibility and capability of browser-based Geolocation, especially on mobile devices as an alternative to native mobile development. The Geolocation API is a &lt;a href="https://www.w3.org/TR/geolocation-API/"&gt;W3C standard&lt;/a&gt; that defines a high-level JavaScript API for websites to query the physical position of a device. According to the ever-useful &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API"&gt;MDN docs&lt;/a&gt;, the APIs are well-supported.&lt;/p&gt;

&lt;p&gt;There are two ways to retrieve location:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Request the device‚Äôs current position (&lt;code&gt;getCurrentPosition&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Track the device‚Äôs position over time (&lt;code&gt;watchPosition&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Both methods can be configured with a timeout, a maximum age (for returning cached data), and an accuracy hint. Returned positions have a timestamp and coordinates, which includes latitude/longitude with 95% confidence range, altitude with 95% confidence range if supported, and speed and heading if supported. Any request for location data will prompt the user for permission.&lt;/p&gt;

&lt;p&gt;Testing across a range of desktop and mobile devices, the behaviour varied somewhat. In particular, the interactions of the location cache with the &lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;maximumAge&lt;/code&gt; options was hard to understand, and &lt;code&gt;maximumAge&lt;/code&gt; wasn‚Äôt always strictly followed.&lt;/p&gt;

&lt;p&gt;I‚Äôve put together &lt;a href="https://daniel.fone.net.nz/browser-geolocation-demo/"&gt;single-page HTML demo&lt;/a&gt;, which is &lt;a href="https://github.com/danielfone/browser-geolocation-demo/"&gt;&amp;lt;200 LOC&lt;/a&gt;. I‚Äôve included an iframe version below.&lt;/p&gt;

&lt;h3 id="notes--questions"&gt;Notes &amp;amp; Questions&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;In almost all of my testing, the actual location was within the 95% area returned by &lt;code&gt;getCurrentPosition&lt;/code&gt;, but I think this depends on WiFi SSID mapping. The spec doesn‚Äôt care how the device determines it‚Äôs position beyond the &lt;code&gt;enableHighAccuracy&lt;/code&gt; option. For example, &lt;a href="https://support.apple.com/en-us/HT207092"&gt;Apple&lt;/a&gt; uses ‚ÄúGPS and Bluetooth (where they‚Äôre available), along with crowd-sourced Wi-Fi hotspots and cellular towers to determine the approximate location of your device.‚Äù&lt;/li&gt;
  &lt;li&gt;The &lt;code&gt;enableHighAccuracy&lt;/code&gt; option is indicative only, in mobile Safari this can be disabled.&lt;/li&gt;
  &lt;li&gt;How do devices determine 95% confidence (&lt;code&gt;accuracy&lt;/code&gt; and &lt;code&gt;altitudeAccuracy&lt;/code&gt;) is this consistent across devices?&lt;/li&gt;
  &lt;li&gt;According to the spec, the successCallback for &lt;code&gt;watchPosition&lt;/code&gt; ‚Äúis only invoked when a new position is obtained and this position differs significantly from the previously reported position. The definition of what constitutes a significant difference is left to the implementation.‚Äù In my testing, this was called every few seconds on a stationary device.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="further-reading"&gt;Further Reading&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Geolocation API Specification ‚Äî 2nd Edition 8 November 2016 at time of writing. &lt;a href="https://www.w3.org/TR/geolocation-API/"&gt;https://www.w3.org/TR/geolocation-API/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Current draft of above ‚Äî¬†&lt;a href="https://w3c.github.io/geolocation-api/"&gt;https://w3c.github.io/geolocation-api/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Geolocation API on the MDN web docs ‚Äî¬†&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API"&gt;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;iframe src="https://daniel.fone.net.nz/browser-geolocation-demo/" width="100%" height="700"&gt;&lt;/iframe&gt;
</content>
  </entry>
  <entry>
    <title>Timing-Safe bcrypt Authentication in PostgreSQL</title>
    <link rel="alternate" href="http://daniel.fone.net.nz/blog/2020/09/09/timing-safe-bcrypt-authentication-in-postgresql/"/>
    <id>http://daniel.fone.net.nz/blog/2020/09/09/timing-safe-bcrypt-authentication-in-postgresql/</id>
    <published>2020-09-09T18:53:00+12:00</published>
    <updated>2020-10-22T20:50:44+13:00</updated>
    <author>
      <name>Daniel Fone</name>
    </author>
    <content type="html">&lt;p&gt;Many applications aim to prevent &lt;a href="https://blog.rapid7.com/2017/06/15/about-user-enumeration/"&gt;user enumeration&lt;/a&gt; during authentication, particularly if users authenticate themselves with some PII like an email address. Well-designed login forms usually don‚Äôt disclose whether the username or password is incorrect, both because the response can be misleading,&lt;sup id="fnref:1" role="doc-noteref"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; and because it will disclose the presence of accounts in the database, facilitating spear-phishing, credential stuffing, and other attacks.&lt;/p&gt;

&lt;p&gt;However, while the response body may not disclose this, often the response time still betrays whether a matching user record exists in the database. Because effective password checking like bcrypt is deliberately so slow, the response is much quicker if there is no digest to compare the submitted plain-text against. This oversight can undermine the ambiguity of the response body and expose users to the attacks mentioned above.&lt;/p&gt;

&lt;p&gt;Let‚Äôs look at an example authentication query in PostgreSQL.&lt;sup id="fnref:2" role="doc-noteref"&gt;&lt;a href="#fn:2" class="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt; First we‚Äôll add a user record.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;users&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;email&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password_digest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'daniel@example.com'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;crypt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'my-password'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;gen_salt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'bf'&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;

&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;users&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;--  id |       email        |                       password_digest&lt;/span&gt;
&lt;span class="c1"&gt;-- ----+--------------------+--------------------------------------------------------------&lt;/span&gt;
&lt;span class="c1"&gt;--   1 | daniel@example.com | $2a$06$xMGQrmx5DrVvfiBqdVhZLeQJOWx95H/B..79VElnBAh/xa5bKGkwG&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;a href="https://www.postgresql.org/docs/12/pgcrypto.html#id-1.11.7.34.6.7"&gt;crypt function&lt;/a&gt; is provided by the pgcrypto module. It takes a plain-text password and a salt, and returns a hash. Since crypt-style hashes include their salt (along with the algorthim details), the same function can be used to generate new hashes or verify existing ones.&lt;sup id="fnref:3" role="doc-noteref"&gt;&lt;a href="#fn:3" class="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt; In this case, we use the gen_salt function to generate a bcrypt salt with the default number of iterations (&lt;code&gt;bf&lt;/code&gt; is for blowfish which is synonymous with bcrypt here). Note that this only uses the first 72 bytes of the plain-text password, a more secure approach is to digest the entire plain-text first.&lt;sup id="fnref:4" role="doc-noteref"&gt;&lt;a href="#fn:4" class="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Now let‚Äôs look at a naive authentication query.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;&lt;span class="c1"&gt;-- Correct username and password&lt;/span&gt;
&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;users&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;email&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'daniel@example.com'&lt;/span&gt;
  &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;password_digest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;crypt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'my-password'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password_digest&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;--  id |       email        |                       password_digest&lt;/span&gt;
&lt;span class="c1"&gt;-- ----+--------------------+--------------------------------------------------------------&lt;/span&gt;
&lt;span class="c1"&gt;--   1 | daniel@example.com | $2a$06$xMGQrmx5DrVvfiBqdVhZLeQJOWx95H/B..79VElnBAh/xa5bKGkwG&lt;/span&gt;
&lt;span class="c1"&gt;--&lt;/span&gt;
&lt;span class="c1"&gt;-- Time: 6.692 ms&lt;/span&gt;

&lt;span class="c1"&gt;-- Incorrect password&lt;/span&gt;
&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;users&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;email&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'daniel@example.com'&lt;/span&gt;
  &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;password_digest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;crypt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'password'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password_digest&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;--  id | email | password_digest&lt;/span&gt;
&lt;span class="c1"&gt;-- ----+-------+-----------------&lt;/span&gt;
&lt;span class="c1"&gt;--&lt;/span&gt;
&lt;span class="c1"&gt;-- Time: 6.513 ms&lt;/span&gt;

&lt;span class="c1"&gt;-- Incorrect email&lt;/span&gt;
&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;users&lt;/span&gt;
&lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;email&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'noone@example.com'&lt;/span&gt;
  &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;password_digest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;crypt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'my-password'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password_digest&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;--  id | email | password_digest&lt;/span&gt;
&lt;span class="c1"&gt;-- ----+-------+-----------------&lt;/span&gt;
&lt;span class="c1"&gt;--&lt;/span&gt;
&lt;span class="c1"&gt;-- Time: 0.432 ms&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As we can see, checking the password against an existing hash takes several milliseconds, whereas checking the index for an email is comparatively instantaneous. This difference is increased depending on the size of the table and the number of bcrypt iterations (Rails defaults to 10). In an application I recently worked on, the difference was measurable even after the jitter introduced by the application code and network latency.&lt;/p&gt;

&lt;p&gt;Whether you‚Äôre comparing the digests in the database like this, or taking the more common approach of comparing the hashes in your application code, &lt;strong&gt;the essential solution is to compare a bcrypt hash even if no real user is found&lt;strong&gt;.&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight sql"&gt;&lt;code&gt;&lt;span class="k"&gt;with&lt;/span&gt;

&lt;span class="c1"&gt;-- select either the id and password digest matching the email, or a dummy row&lt;/span&gt;
&lt;span class="n"&gt;target_user&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password_digest&lt;/span&gt;
  &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password_digest&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;users&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;email&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;password&lt;/span&gt;
    &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="k"&gt;all&lt;/span&gt;
    &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;gen_salt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'bf'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;-- a random salt&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;users&lt;/span&gt;
  &lt;span class="k"&gt;limit&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;-- only return the first row, either the real id+digest or the "null" one&lt;/span&gt;
&lt;span class="p"&gt;),&lt;/span&gt;

&lt;span class="c1"&gt;-- perform bcrypt matching on the guaranteed single row from target_user&lt;/span&gt;
&lt;span class="n"&gt;valid_user&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;target_user&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;password_digest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;crypt&lt;/span&gt;&lt;span class="p"&gt;(:&lt;/span&gt;&lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password_digest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;-- select the row from the users table matching the authenticated id&lt;/span&gt;
&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;users&lt;/span&gt; &lt;span class="k"&gt;natural&lt;/span&gt; &lt;span class="k"&gt;join&lt;/span&gt; &lt;span class="n"&gt;valid_user&lt;/span&gt; &lt;span class="k"&gt;limit&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Clearly, this query is a lot more complex than our naive approach, however with judicious use of comments and well-factored subqueries, I think the intention remains relatively clear. Perhaps there are simpler ways to factor this query and achieve the same result ‚Äî¬†I‚Äôd love to see some alternatives! No matter how it‚Äôs achieved though, the only way to ensure that the response is truly opaque is to do the same work in all cases. One way or another we need to hash the supplied plain-text.&lt;/p&gt;

&lt;div class="footnotes" role="doc-endnotes"&gt;
  &lt;ol&gt;
    &lt;li id="fn:1" role="doc-endnote"&gt;
      &lt;p&gt;For example, the user may be entering their password, but have the username wrong. See &lt;a href="https://ux.stackexchange.com/questions/13516/how-to-tell-the-user-his-login-credentials-are-incorrect/13523#13523"&gt;this discussion&lt;/a&gt; on the UX StackExchange.¬†&lt;a href="#fnref:1" class="reversefootnote" role="doc-backlink"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id="fn:2" role="doc-endnote"&gt;
      &lt;p&gt;In my experience, most applications perform this authentication check in application code rather than at the database level. The argument for this is that it‚Äôs better to discard plain-text password as early in the process as possible. This seems reasonable to me. Perhaps even more reasonable is digesting the plain-text in the browser before it‚Äôs transmitted to the app server for authentication. There may be other drawbacks for this though - comment is welcome!¬†&lt;a href="#fnref:2" class="reversefootnote" role="doc-backlink"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id="fn:3" role="doc-endnote"&gt;
      &lt;p&gt;Technically, this hash format is the &lt;a href="https://passlib.readthedocs.io/en/stable/modular_crypt_format.html"&gt;Modular Crypt Format&lt;/a&gt; or &lt;a href="https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md"&gt;PHC string format&lt;/a&gt;¬†&lt;a href="#fnref:3" class="reversefootnote" role="doc-backlink"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id="fn:4" role="doc-endnote"&gt;
      &lt;p&gt;For example, using &lt;code&gt;digest(:password, 'sha1')::text&lt;/code&gt; would ensure we include all the entropy from the user-supplied password into the hash. The same digest would need to be applied before verifying a password for authentication.¬†&lt;a href="#fnref:4" class="reversefootnote" role="doc-backlink"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>Handling Token Generation Collisions In ActiveRecord</title>
    <link rel="alternate" href="http://daniel.fone.net.nz/blog/2014/12/10/handling-token-generation-collisions-in-activerecord/"/>
    <id>http://daniel.fone.net.nz/blog/2014/12/10/handling-token-generation-collisions-in-activerecord/</id>
    <published>2014-12-10T12:28:00+13:00</published>
    <updated>2020-10-22T20:50:39+13:00</updated>
    <author>
      <name>Daniel Fone</name>
    </author>
    <content type="html">&lt;p&gt;In my &lt;a href="/blog/2014/12/07/generating-unique-random-tokens/"&gt;previous post&lt;/a&gt; we looked at generating unique, random tokens to securely identify records with. While UUIDs solve this problem well, they are unweidly. In some cases, it‚Äôs handy to have an identifier that‚Äôs shorter and hence easier to read out. Naturally, the problem with shorter tokens is collisions. As we reduce our available pool of tokens, the chance that a randomly selected one will be unique goes down quickly.&lt;/p&gt;

&lt;p&gt;Whether this trade off makes sense is entirely dependent on the application. Let‚Äôs say we‚Äôre identifying an order in a particular month. If we need a short, readable token that‚Äôs unique &lt;em&gt;only among this month‚Äôs orders&lt;/em&gt;, we can probably use a short token. This is because the number of orders in a given month is not going to grow linearly ‚Äî we can expect it to hover around a certain percentage of the total available tokens.&lt;/p&gt;

&lt;p&gt;So let‚Äôs say we need to keep track of a hundred thousand constantly changing items with a six digit, hexadecimal token. The chance of a random token colliding with an existing one is going to be roughly 0.3%.&lt;sup id="fnref:1" role="doc-noteref"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; While this isn‚Äôt going to happen frequently, we definitely need to handle the case gracefully.&lt;/p&gt;

&lt;h3 id="a-first-attempt"&gt;A First Attempt&lt;/h3&gt;

&lt;p&gt;The trick is to set the token in a separate SQL query. ActiveRecord‚Äôs &lt;code&gt;after_create&lt;/code&gt; is a good fit for this kind of task. In the event of a collision, ActiveRecord will handily raise an &lt;code&gt;ActiveRecord::RecordNotUnique&lt;/code&gt; which we can rescue and retry. If we were setting the token in a &lt;code&gt;before_create&lt;/code&gt;, we wouldn‚Äôt be able to simply retry the save.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Order&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;

  &lt;span class="n"&gt;after_create&lt;/span&gt; &lt;span class="ss"&gt;:generate_token&lt;/span&gt;

&lt;span class="kp"&gt;private&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generate_token&lt;/span&gt;
    &lt;span class="n"&gt;update_column&lt;/span&gt; &lt;span class="ss"&gt;:token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;rescue&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;RecordNotUnique&lt;/span&gt;
    &lt;span class="k"&gt;retry&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;&amp;gt; Order.create!
  DEBUG -- SQL (0.1ms)  begin transaction
  DEBUG -- SQL (0.1ms)  INSERT INTO "orders" DEFAULT VALUES
  DEBUG -- SQL (2.6ms)  UPDATE "orders" SET "token" = '99a8b4' WHERE "orders"."id" = 9
  ERROR -- SQLite3::ConstraintException: UNIQUE constraint failed: orders.token: UPDATE "orders" SET "token" = '99a8b4' WHERE "orders"."id" = 9
  DEBUG -- SQL (0.1ms)  UPDATE "orders" SET "token" = 'd776b10' WHERE "orders"."id" = 9
  DEBUG -- SQL (0.1ms)  commit transaction
=&amp;gt; #&amp;lt;Order id: 9, token: "d776b10"&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not bad for a first try.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;SecureRandom.hex(3)&lt;/code&gt; produces something like &lt;code&gt;"c41a84"&lt;/code&gt; which is what our tokens should look like.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;update_column&lt;/code&gt; is the fastest way to update the attribute because it goes straight to the database. It‚Äôs been around since Rails 3.1.&lt;/li&gt;
  &lt;li&gt;We‚Äôre only rescuing in the event of a token collision (&lt;code&gt;ActiveRecord::RecordNotUnique&lt;/code&gt;), so it‚Äôs pretty much safe to just retry. But‚Ä¶&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="limited-retries"&gt;Limited Retries&lt;/h3&gt;

&lt;p&gt;While this works, it‚Äôs a bad idea to blindly retry without some kind of limit on the number of retries. Even if the system is designed so that the chances of multiple consecutive collisions are tiny, you never know when the system will start operating outside of its original design.&lt;/p&gt;

&lt;p&gt;Let‚Äôs introduce a variable to monitor how many retries we‚Äôve made.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generate_token&lt;/span&gt;
  &lt;span class="n"&gt;update_column&lt;/span&gt; &lt;span class="ss"&gt;:token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;rescue&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;RecordNotUnique&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
  &lt;span class="vi"&gt;@token_attempts&lt;/span&gt; &lt;span class="o"&gt;||=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
  &lt;span class="vi"&gt;@token_attempts&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="k"&gt;retry&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vi"&gt;@token_attempts&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
  &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Retries exhausted"&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;DEBUG -- SQL (0.0ms)  begin transaction
DEBUG -- SQL (0.0ms)  INSERT INTO "orders" DEFAULT VALUES
DEBUG -- SQL (0.1ms)  UPDATE "orders" SET "token" = 'c3' WHERE "orders"."id" = 32
ERROR -- SQLite3::ConstraintException: UNIQUE constraint failed: orders.token: UPDATE "orders" SET "token" = 'c3' WHERE "orders"."id" = 32
DEBUG -- SQL (0.1ms)  UPDATE "orders" SET "token" = '50' WHERE "orders"."id" = 32
ERROR -- SQLite3::ConstraintException: UNIQUE constraint failed: orders.token: UPDATE "orders" SET "token" = '50' WHERE "orders"."id" = 32
DEBUG -- SQL (0.2ms)  UPDATE "orders" SET "token" = 'cb' WHERE "orders"."id" = 32
ERROR -- SQLite3::ConstraintException: UNIQUE constraint failed: orders.token: UPDATE "orders" SET "token" = 'cb' WHERE "orders"."id" = 32
DEBUG -- SQL (0.1ms)  rollback transaction
ActiveRecord::RecordNotUnique: Retries exhausted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That‚Äôs functional, but it could be improved. Here‚Äôs a slightly nicer version.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="no"&gt;MAX_RETRIES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generate_token&lt;/span&gt;
  &lt;span class="n"&gt;update_column&lt;/span&gt; &lt;span class="ss"&gt;:token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;rescue&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;RecordNotUnique&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
  &lt;span class="vi"&gt;@token_attempts&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="vi"&gt;@token_attempts&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;to_i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="k"&gt;retry&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vi"&gt;@token_attempts&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;MAX_RETRIES&lt;/span&gt;
  &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Retries exhausted"&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A few notes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;@token_attempts.to_i&lt;/code&gt; will evaluate to 0 if &lt;code&gt;@token_attempts&lt;/code&gt; hasn‚Äôt been previously set. This is because unassigned instance variables are &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;nil.to_i =&amp;gt; 0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;It‚Äôs also a good habit to name our fixed numbers via constants. In the original version, the number the 3 was a bit of a magic number. &lt;code&gt;MAX_RETRIES&lt;/code&gt; communicates exactly what this number represents and makes it clear where to change it.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Our &lt;code&gt;raise&lt;/code&gt; encapsulates the original exception with a more helpful message. &lt;code&gt;e.cause&lt;/code&gt; is set to the rescued exception:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;[1] pry(#&amp;lt;Order&amp;gt;)&amp;gt; e
=&amp;gt; #&amp;lt;ActiveRecord::RecordNotUnique: Retries exhausted&amp;gt;
[2] pry(#&amp;lt;Order&amp;gt;)&amp;gt; e.cause
=&amp;gt; #&amp;lt;ActiveRecord::RecordNotUnique: SQLite3::ConstraintException: UNIQUE constraint failed: orders.token: UPDATE "orders" SET "token" = '58' WHERE "orders"."id" = 68&amp;gt;
[3] pry(#&amp;lt;Order&amp;gt;)&amp;gt; e.cause.cause
=&amp;gt; #&amp;lt;SQLite3::ConstraintException: UNIQUE constraint failed: orders.token&amp;gt;
[4] pry(#&amp;lt;Order&amp;gt;)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There we have it. If the use-case is right, this is a safe and simple pattern for generating tokens on an ActiveRecord object where there is a reasonable possibility of collisions.&lt;/p&gt;

&lt;div class="footnotes" role="doc-endnotes"&gt;
  &lt;ol&gt;
    &lt;li id="fn:1" role="doc-endnote"&gt;
      &lt;p&gt;Once again using the square approximation of the &lt;a href="http://en.wikipedia.org/wiki/Birthday_problem"&gt;Birthday Problem&lt;/a&gt;. &lt;a href="http://www.wolframalpha.com/input/?i=100000+%2F+%282+*+%2816%5E6%29%29"&gt;WolframAlpha&lt;/a&gt;.¬†&lt;a href="#fnref:1" class="reversefootnote" role="doc-backlink"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>Generating Unique, Random Tokens</title>
    <link rel="alternate" href="http://daniel.fone.net.nz/blog/2014/12/07/generating-unique-random-tokens/"/>
    <id>http://daniel.fone.net.nz/blog/2014/12/07/generating-unique-random-tokens/</id>
    <published>2014-12-07T21:10:00+13:00</published>
    <updated>2020-10-22T20:50:37+13:00</updated>
    <author>
      <name>Daniel Fone</name>
    </author>
    <content type="html">&lt;p&gt;Generating some kind of token for records is a common problem in web development. Fortunately, &lt;a href="http://tools.ietf.org/html/rfc4122"&gt;UUIDs&lt;/a&gt; are designed precisely for generating unique, random IDs or tokens. For most applications, you‚Äôll probably want a fully random &lt;a href="http://tools.ietf.org/html/rfc4122#section-4.4"&gt;v4 UUID&lt;/a&gt;, which you can easily generate with &lt;a href="http://www.ruby-doc.org/stdlib-2.1.4/libdoc/securerandom/rdoc/SecureRandom.html#method-c-uuid"&gt;SecureRandom&lt;/a&gt; in Ruby‚Äôs standard library.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;'securerandom'&lt;/span&gt;
&lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;uuid&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; "16fc1d86-7d6e-4011-9b75-d6cd9501fe1e"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a widely implemented&lt;sup id="fnref:1" role="doc-noteref"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; and instantly recognisable format that is vanishingly unlikely to have a collision.&lt;sup id="fnref:2" role="doc-noteref"&gt;&lt;a href="#fn:2" class="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Now, as an engineer, ‚Äúunlikely‚Äù makes me nervous. I confess I don‚Äôt have an intuitive grasp of the statistics involved, and to me the two options are ‚Äúcan‚Äôt happen‚Äù or ‚Äúwill happen‚Äù. Although my rational brain knows better, I still instinctively put ‚Äúvanishingly unlikely‚Äù in the ‚Äúwill happen‚Äù category. Sure, a collision might be unlikely if we‚Äôre only dealing with a small number of records, but what if we‚Äôre dealing with BigData‚Ñ¢?&lt;/p&gt;

&lt;p&gt;Well let me put it in perspective for you: you‚Äôd have to generate 112 terabytes of UUIDs before you‚Äôd even have a &lt;em&gt;one in a billion&lt;/em&gt; chance of a collision.&lt;sup id="fnref:3" role="doc-noteref"&gt;&lt;a href="#fn:3" class="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt; So unless you‚Äôve got a 112 terabyte database to fill with UUIDs, you‚Äôre going to have a lot of other problems first.&lt;/p&gt;

&lt;p&gt;How would this look in practice then? If I wanted a token for an ActiveRecord object, it‚Äôd look something like:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Order&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
  &lt;span class="n"&gt;before_create&lt;/span&gt; &lt;span class="ss"&gt;:generate_token&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;unless: :token?&lt;/span&gt;
&lt;span class="kp"&gt;private&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;generate_token&lt;/span&gt;
    &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;token&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;uuid&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now you probably want an index on the &lt;code&gt;token&lt;/code&gt; column, so you might as well make it a unique index. However, a collision is so unlikely to occur there‚Äôs really no point handling the RecordNotUnique exception that would be raised in that event.&lt;/p&gt;

&lt;h3 id="other-formats"&gt;Other Formats&lt;/h3&gt;

&lt;p&gt;The downside of UUID is that it‚Äôs rather unwieldy. It uses 36 characters to render 16 bytes of entroy.&lt;sup id="fnref:4" role="doc-noteref"&gt;&lt;a href="#fn:4" class="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt; Naturally, there are plenty of other ways to render 16 bytes of entropy and still have the same statistical properties outlined above.&lt;/p&gt;

&lt;p&gt;SecureRandom offers a few other helpful methods for generating token-like strings. My two preferred choices are &lt;code&gt;hex&lt;/code&gt; and &lt;code&gt;urlsafe_base64&lt;/code&gt;. Here they all are for comparison.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;uuid&lt;/span&gt;           &lt;span class="c1"&gt;# =&amp;gt; "8efb5d40-32d8-43c8-a92d-d5f048c8729c"&lt;/span&gt;
&lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hex&lt;/span&gt;            &lt;span class="c1"&gt;# =&amp;gt; "bad6650fc0142451e624bd89b6aa3acf"&lt;/span&gt;
&lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;urlsafe_base64&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; "vp6xjBgi48Jgag6dqH8niw"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="short-memorable-readable-tokens"&gt;Short, Memorable, Readable Tokens&lt;/h3&gt;

&lt;p&gt;What about if the token needs to be really short? I once worked on a project where certain customer facing records had an easy to read reference made of 6 hexadecimal digits. In that case, we only want 3 bytes, and the &lt;code&gt;hex&lt;/code&gt; method conveniently allows us to specify how many bytes we‚Äôll need.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="no"&gt;SecureRandom&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; "bff1a1"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Of course, now we‚Äôre only dealing with 16,777,216 possible tokens and collisions are inevitable. In my &lt;a href="/blog/2014/12/10/handling-token-generation-collisions-in-activerecord/"&gt;next post&lt;/a&gt;, we‚Äôll take a look at effective ways to deal with token collisions for ActiveRecord objects.&lt;/p&gt;

&lt;div class="footnotes" role="doc-endnotes"&gt;
  &lt;ol&gt;
    &lt;li id="fn:1" role="doc-endnote"&gt;
      &lt;p&gt;You can even generate one from the command line of most *nix systems with &lt;code&gt;uuidgen&lt;/code&gt;.¬†&lt;a href="#fnref:1" class="reversefootnote" role="doc-backlink"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id="fn:2" role="doc-endnote"&gt;
      &lt;p&gt;This ‚Äî¬†and the discussion after it ‚Äî¬†is assuming that the PRNG has sufficient entropy. SecureRandom‚Äôs entropy source is system-dependent.¬†&lt;a href="#fnref:2" class="reversefootnote" role="doc-backlink"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id="fn:3" role="doc-endnote"&gt;
      &lt;p&gt;Given that a UUID is 36 bytes, we want to know how many UUIDs (of which there are 2&lt;sup&gt;112&lt;/sup&gt; total) will give us a one in a billion (2&lt;sup&gt;-30&lt;/sup&gt;) chance of collision. We can plug the square approximation for the &lt;a href="http://en.wikipedia.org/wiki/Birthday_problem"&gt;Birthday Problem&lt;/a&gt; into WolframAlpha to get &lt;a href="http://www.wolframalpha.com/input/?i=sqrt%282+*+2%5E112+*+2%5E-30%29+*+36+bytes"&gt;the result&lt;/a&gt;.¬†&lt;a href="#fnref:3" class="reversefootnote" role="doc-backlink"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id="fn:4" role="doc-endnote"&gt;
      &lt;p&gt;It‚Äôs actually 122 bits since 6 of 128 bits are fixed as per the &lt;a href="http://tools.ietf.org/html/rfc4122#section-4.4"&gt;RFC&lt;/a&gt;.¬†&lt;a href="#fnref:4" class="reversefootnote" role="doc-backlink"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>Efficient Uniqueness Validations</title>
    <link rel="alternate" href="http://daniel.fone.net.nz/blog/2014/12/05/efficient-uniqueness-validations/"/>
    <id>http://daniel.fone.net.nz/blog/2014/12/05/efficient-uniqueness-validations/</id>
    <published>2014-12-05T13:31:00+13:00</published>
    <updated>2014-12-07T21:12:44+13:00</updated>
    <author>
      <name>Daniel Fone</name>
    </author>
    <content type="html">&lt;p&gt;Although ActiveRecord uniqueness validations aren‚Äôt bullet-proof,&lt;sup id="fnref:1" role="doc-noteref"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; they‚Äôre often helpful. Unfortunately, they can add overhead to save operations, since they require an extra call to the database. Consider the following simple ActiveRecord class:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SubscriptionPlan&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
  &lt;span class="n"&gt;validates&lt;/span&gt; &lt;span class="ss"&gt;:code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;uniqueness: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
  &lt;span class="n"&gt;validates_uniqueness_of&lt;/span&gt; &lt;span class="ss"&gt;:name&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When we try to create this we‚Äôll see two SELECT queries as we‚Äôd expect.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt; &amp;gt;&amp;gt; SubscriptionPlan.create! name: 'Starter - 100', code: 'starter-100'
   (0.2ms)  BEGIN
  SubscriptionPlan Exists (2.1ms)  SELECT  1 AS one FROM "subscription_plans"  WHERE "subscription_plans"."code" = 'starter-100' LIMIT 1
  SubscriptionPlan Exists (0.2ms)  SELECT  1 AS one FROM "subscription_plans"  WHERE "subscription_plans"."name" = 'Starter - 100' LIMIT 1
   (0.1ms)  ROLLBACK
ActiveRecord::RecordInvalid: Validation failed: Code has already been taken, Name has already been taken
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But what about when we update an existing record?&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;&amp;gt;&amp;gt; plan.update_attributes! quota: 99
   (0.2ms)  BEGIN
    SubscriptionPlan Exists (0.4ms)  SELECT  1 AS one FROM "subscription_plans"  WHERE ("subscription_plans"."code" = 'starter-100' AND "subscription_plans"."id" != 1) LIMIT 1
    SubscriptionPlan Exists (0.2ms)  SELECT  1 AS one FROM "subscription_plans"  WHERE ("subscription_plans"."name" = 'Starter - 100' AND "subscription_plans"."id" != 1) LIMIT 1
  SQL (0.7ms)  UPDATE "subscription_plans" SET "quota" = $1, "updated_at" = $2 WHERE "subscription_plans"."id" = 1  [["quota", 99], ["updated_at", "2014-12-05 00:40:59.969458"]]
   (0.3ms)  COMMIT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We still get two queries to check if the code and name are unique. These are almost certainly pointless, since neither the name or the code have changed, but they‚Äôre being checked anyway. On massive tables, these can be costly queries, even with well designed indexes.&lt;/p&gt;

&lt;h3 id="activemodeldirty-to-the-rescue"&gt;ActiveModel::Dirty to the Rescue&lt;/h3&gt;

&lt;p&gt;Fortunately, it‚Äôs quite simple to keep these queries in check. &lt;a href="http://api.rubyonrails.org/classes/ActiveModel/Dirty.html"&gt;ActiveModel::Dirty&lt;/a&gt; lets us check if any fields were changed since the record was loaded.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SubscriptionPlan&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
  &lt;span class="n"&gt;validates&lt;/span&gt; &lt;span class="ss"&gt;:code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;uniqueness: &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;if: :code_changed?&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;validates_uniqueness_of&lt;/span&gt; &lt;span class="ss"&gt;:name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;if: :name_changed?&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, create operations behave the same as before, validating the uniqueness of the fields. Likewise if we update one of those fields, it will query only the fields it needs to check.&lt;/p&gt;

&lt;p&gt;On the other hand, an update that doesn‚Äôt affect those fields won‚Äôt incur the cost of those potentially expensive SELECTS.&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre class="highlight plaintext"&gt;&lt;code&gt;&amp;gt;&amp;gt; plan.update_attributes! quota: 99
   (0.2ms)  BEGIN
  SQL (0.7ms)  UPDATE "subscription_plans" SET "quota" = $1, "updated_at" = $2 WHERE "subscription_plans"."id" = 1  [["quota", 99], ["updated_at", "2014-12-05 00:40:59.969458"]]
   (0.3ms)  COMMIT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is much better. However, I think we can do better still. In a future post I‚Äôll look at ways we can bypass manual uniqueness validations entirely.&lt;/p&gt;

&lt;div class="footnotes" role="doc-endnotes"&gt;
  &lt;ol&gt;
    &lt;li id="fn:1" role="doc-endnote"&gt;
      &lt;p&gt;Application level uniqueness checks are subject to race conditions, since they use separate check and set queries. They should (almost) always be used in conjunction with a unique index at the database level. See the &lt;a href="http://api.rubyonrails.org/classes/ActiveRecord/Validations/ClassMethods.html#method-i-validates_uniqueness_of"&gt;validates_uniqueness_of docs&lt;/a&gt; for more details.¬†&lt;a href="#fnref:1" class="reversefootnote" role="doc-backlink"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
</feed>
